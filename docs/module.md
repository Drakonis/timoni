# Module Structure

A Timoni module contains a set of CUE definitions and constraints organised
into a [CUE module](https://cuelang.org/docs/concepts/packages/)
with an opinionated file structure.

## File Structure

A module consists of a collection of CUE files inside a directory
with the following structure:

```sh
myapp
├── README.md
├── cue.mod
│   ├── gen # Kubernetes types
│   ├── pkg # Timoni types
│   └── module.cue # Module metadata
├── templates
│   ├── config.cue # Config schema and default values
│   ├── deployment.cue # Kubernetes Deployment template
│   └── service.cue # Kubernetes Service template
├── timoni.cue # Timoni entry point
├── timoni.ignore # Ignore rules
└── values.cue # Timoni values placeholder
```

To create a new module in the current directory:

```shell
timoni mod init myapp .
```

## Entry point

The `timoni.cue` file contains the definition of how Timoni should
validate, build and deploy a module instance.

This file is generated by `timoni mod init` with the following content:

```cue
// source: myapp/timoni.cue

package main

import (
	templates "timoni.sh/myapp/templates"
)

// Define the schema for the user-supplied values.
// At runtime, Timoni injects the supplied values
// and validates them according to the Config schema.
values: templates.#Config

// Define how Timoni should build, validate and
// apply the Kubernetes resources.
timoni: {
	apiVersion: "v1alpha1"

	// Define the instance that generates the Kubernetes resources.
	// At runtime, Timoni builds the instance and validates
	// the resulting resources according to their Kubernetes schema.
	instance: templates.#Instance & {
		// The user-supplied values are merged with the
		// default values at runtime by Timoni.
		config: values
		// These values are injected at runtime by Timoni.
		config: {
			metadata: {
				name:      string @tag(name)
				namespace: string @tag(namespace)
			}
			moduleVersion: string @tag(mv, var=moduleVersion)
			kubeVersion:   string @tag(kv, var=kubeVersion)
		}
	}

	// Enforce minimum Kubernetes version.
	kubeMinorVersion: int & >=20
	kubeMinorVersion: strconv.Atoi(strings.Split(instance.config.kubeVersion, ".")[1])
	
	// Pass the generated Kubernetes resources
	// to Timoni's multi-step apply.
	apply: all: [ for obj in instance.objects {obj}]
}
```

### Enforce Kubernetes minimum version

At apply-time, Timoni injects the Kubernetes version from the live cluster.
You can set a constraint for the minor version e.g. `kubeMinorVersion: int & >=20`.

To test the constraint, you can use the `TIMONI_KUBE_VERSION` env var with `timoni mod lint` and `timoni build`.

```console
$ TIMONI_KUBE_VERSION=1.19.0 timoni mod lint ./myapp
build failed: timoni.kubeMinorVersion: invalid value 19 (out of bound >=20)
```

## Ignore

The `timoni.ignore` file contains rules in the
[.gitignore pattern format](https://git-scm.com/docs/gitignore#_pattern_format).
The paths matching the defined rules are excluded when publishing
the module to a container registry.

When publishing modules as OCI artifacts, it is recommended to use the following ignore patterns:

```.gitignore
# VCS
.git/
.gitignore
.gitmodules
.gitattributes

# Go
vendor/
go.mod
go.sum

# CUE
*_tool.cue

# Timoni
timoni.ignore
```

## Values

The `values.cue` file holds the default values.
Note that this file must have no imports and all values must be concrete.

```cue
// source: myapp/values.cue

values: {
    message: "Hello World"
    image: {
        repository: "cgr.dev/chainguard/nginx"
        digest:     "sha256:d2b0e52d7c2e5dd9fe5266b163e14d41ed97fd380deb55a36ff17efd145549cd"
        tag:        "1.25.1"
    }
}
```


The `values` schema is set in the `timoni.cue` file:

```cue
// source: myapp/timoni.cue

values: templates.#Config
```

Note that the `README.md` file should contain the config values schema documentation.

## Templates

The templates directory is where module authors define Kubernetes resources
and their configuration schema.

### Config

The schema and defaults for the user-supplied values are defined in `templates/config.cue`.

Example of a minimal config for an app deployment:

```cue
// source: myapp/templates/config.cue

#Config: {
	metadata: metav1.#ObjectMeta
	metadata: name:      *"myapp" | string
	metadata: namespace: *"default" | string
	metadata: annotations?: {[string]: string}
	
    image: timoniv1.#Image

    replicas: *1 | int & >0
    service: port: *80 | int & >0 & <=65535
	resources?: corev1.#ResourceRequirements
}
```

The user-supplied values can:

- set a different value for the fields with defaults e.g. the service port
- add labels to metadata except for the name and version
- add annotations to metadata
- set resource requirements requests and/or limits

```cue
// source: myapp-values/values.cue

values: {
	service: port: 8080
	metadata: annontations: "org/owner": "dev-team"
	resources: limits: memory: "1Gi"
}
```

### Instance

Example of defining an instance containing a Kubernetes Service and Deployment:

```cue
// source: myapp/templates/config.cue

#Instance: {
	config: #Config

	objects: {
		svc:    #Service & {_config:        config}
		deploy: #Deployment & {_config:     config}
	}
}
```

### Kubernetes resources

Example of a Kubernetes Service template:

```cue
// source: myapp/templates/service.cue

package templates

import (
	corev1 "k8s.io/api/core/v1"
)

#Service: corev1.#Service & {
	_config:    #Config
	apiVersion: "v1"
	kind:       "Service"
	metadata:   _config.metadata
	spec:       corev1.#ServiceSpec & {
		type:     corev1.#ServiceTypeClusterIP
		selector: _config.metadata.labels
		ports: [
			{
				name:       "http"
				targetPort: name
				port:       _config.service.port
			},
		]
	}
}
```

### Controlling the apply behaviour

Timoni allows module authors to change the default apply behaviour of Kubernetes resources
using the following annotations:

| Annotation                 | Values               |
|----------------------------|----------------------|
| `action.timoni.sh/force`   | `enabled`/`disabled` |
| `action.timoni.sh/one-off` | `enabled`/`disabled` |
| `action.timoni.sh/prune`   | `enabled`/`disabled` |

To recreate immutable resources such as Kubernetes Jobs,
these resources can be annotated with `action.timoni.sh/force: "enabled"`.

To apply resources only if they don't exist on the cluster,
these resources can be annotated with `action.timoni.sh/one-off: "enabled"`.

To prevent Timoni's garbage collector from deleting certain
resources such as Kubernetes Persistent Volumes,
these resources can be annotated with `action.timoni.sh/prune: "disabled"`.

## Kubernetes types

The `cue.mod` directory contains the Kubernetes types and their schema.
These files are automatically generated by CUE from the Kubernetes API Go packages.

```shell
./myapp/cue.mod/
├── gen
│   └── k8s.io
│       ├── api
│       │   ├── apps
│       │   └── core
│       └── apimachinery
└── module.cue
```

To update the schemas to a specific Kubernetes version, run the following commands
from within the `myapp` directory:

```shell
# download the Kubernetes Go APIs
go get k8s.io/api/...@v0.28.1

# generate the CUE types for v1 core and apps APIs
cue get go k8s.io/api/core/v1
cue get go k8s.io/api/apps/v1
```

To add other Kubernetes types e.g. `Ingress` and `NetworkPolicy`:

```shell
cue get go k8s.io/api/networking/v1
```

### Kubernetes CRDs

To add 3rd-party Kubernetes types e.g. Prometheus Operator `ServiceMonitor`:

```shell
# download the Prometheus Operator Go APIs
go get github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1@v0.63.0

# generate the CUE types for v1 monitoring APIs
cue get go github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1
```

The Kubernetes CUE types are used in templates to set the validation schema of a resource e.g.:

```cue
package templates

import (
	promv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
)

#ServiceMonitor: promv1.#ServiceMonitor & {
	_config:    #Config
	apiVersion: "monitoring.coreos.com/v1"
	kind:       promv1.#ServiceMonitorsKind
	metadata:   _config.metadata
	spec: {
		endpoints: [{
			path:     "/metrics"
			port:     "http-metrics"
			interval: _config.monitoring.interval
		}]
		namespaceSelector: matchNames: [_config.metadata.namespace]
		selector: matchLabels: _config.selectorLabels
	}
}
```
